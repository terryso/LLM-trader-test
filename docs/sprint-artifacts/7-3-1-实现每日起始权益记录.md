# Story 7.3.1: 实现每日起始权益记录

Status: done

## Story

As a system,
I want to record daily starting equity,
so that daily loss can be calculated accurately and can drive daily loss limit checks.

## Acceptance Criteria

1. **AC1 – 每日基准记录逻辑（RiskControlState 对齐 Epic 7.1/7.3）**  
   - 在每轮 `_run_iteration()` 开始阶段（加载状态之后、进行 Kill-Switch / 每日亏损检查之前），系统调用一个集中封装的 helper（例如 `update_daily_baseline(state: RiskControlState, current_equity: float)`）：  
     - helper 读取当前 `RiskControlState`；  
     - 计算当前 UTC 日期字符串 `today = datetime.now(timezone.utc).strftime("%Y-%m-%d")`；  
     - 当 `state.daily_start_date != today` 时：  
       - 将 `state.daily_start_date` 设为 `today`；  
       - 将 `state.daily_start_equity` 设为 `current_equity`；  
       - 将 `state.daily_loss_pct` 重置为 `0.0`；  
       - 将 `state.daily_loss_triggered` 重置为 `False`。  
     - 当 `state.daily_start_date == today` 时：  
       - 不修改上述字段（避免在同一自然日内多次重置基准）。

2. **AC2 – 与风控检查流程的集成（不改变 Kill-Switch 既有语义）**  
   - `update_daily_baseline(...)` 的调用位置满足：  
     - 在本轮迭代的风控检查入口（例如 `check_risk_limits(...)`）及每日亏损百分比计算（Story 7.3.2）之前完成；  
     - 不修改现有 Kill-Switch 字段（`kill_switch_active` / `kill_switch_reason` / `kill_switch_triggered_at`），也不改变其当前在 `check_risk_limits(...)` 中的行为语义。  
   - 在 `RISK_CONTROL_ENABLED=False` 时：  
     - 可以选择跳过 `update_daily_baseline(...)` 调用，或在实现中保证其为幂等的 no-op，二者其一即可，但需要在 Dev Notes 中记录最终决策。  
   - 本 Story 不引入任何对 LLM 决策过滤、新开仓允许/禁止逻辑的修改；相关逻辑继续由已实现的 Kill-Switch / 信号过滤 Stories（7.2.1、7.2.2、7.2.3 等）负责。

3. **AC3 – 持久化与重启语义（与 FR1–FR4 对齐）**  
   - 当 `update_daily_baseline(...)` 导致 `RiskControlState` 发生变更时：  
     - 通过现有的状态保存路径（例如 `core.state.save_state()` / `core.persistence.save_state_to_json()`）将更新后的 `risk_control` 字段持久化到 `portfolio_state.json`；  
     - 状态文件中的 `risk_control.daily_start_equity` / `daily_start_date` / `daily_loss_pct` / `daily_loss_triggered` 字段在下一次重启后能够被 `core.state.load_state()` 正确恢复。  
   - 当 Bot 在同一自然日内重启：  
     - 若 `daily_start_date` 与当前 UTC 日期相同，则本 Story 不改变基准（即不会在同一天「重置」起始权益）；  
     - 若跨 UTC 日重启，则下一轮迭代会像首次启动一样，使用新的 `current_equity` 初始化当日基准。  
   - 当 `portfolio_state.json` 中缺失 `risk_control` 字段或该字段解析失败时：  
     - 保持 Epic 7.1 已定义的容错行为（回退到默认 `RiskControlState()`）；  
     - 本 Story 只要求在下一轮迭代中按 AC1 的规则重新建立当日基准，而不引入新的异常。

4. **AC4 – 日志与可观测性（辅助调试，引用 Tech Spec 建议）**  
   - 当发生「跨日重置」行为（即 `state.daily_start_date != today`）：  
     - 记录一条 INFO 级别的结构化日志，例如：  
       - `"Daily baseline reset: equity=%.2f, date=%s"`；  
     - 日志格式与现有 `core/risk_control.py` / `core/state.py` 中风控相关日志保持一致（遵循 `docs/architecture/07-implementation-patterns.md` 中的日志规则）。  
   - 在同一自然日内的后续迭代中（基准不变化）：  
     - 日志可以完全静默，或使用 DEBUG 级别日志，而不应在 INFO 级别产生噪声；  
     - 最终选择需在 Dev Notes 中注明。

5. **AC5 – 单元与集成测试覆盖（与 Story 7.1.x 一致的测试标准）**  
   - 单元测试至少覆盖以下场景：  
     - `daily_start_date` 为 `None`，首次调用 `update_daily_baseline(...)`：基准被初始化，字段取值正确；  
     - `daily_start_date` 为过去某一日（小于当前 UTC 日期）：调用后重置为今天的日期，`daily_start_equity` 更新为新的 `current_equity`，`daily_loss_pct` 重置为 `0.0`，`daily_loss_triggered` 设为 `False`；  
     - `daily_start_date` 已是今天：重复调用不改变上述字段；  
     - 边界场景：`daily_start_equity` 为 0 或 `None` 时的处理不抛出异常。  
   - 集成测试至少覆盖：  
     - 在模拟的迭代流程中（可通过构造 `RiskControlState` + `current_equity` 调用 `_run_iteration()` 或封装函数），验证跨日与非跨日情况下状态变化是否符合 AC1–AC3。  
   - 运行 `./scripts/run_tests.sh` 或等价命令，所有测试通过（包含新测试和既有 Kill-Switch / 风控相关测试）。

## Tasks / Subtasks

- [ ] **Task 1 – 实现每日基准更新 helper（AC1, AC4）**  
  - [ ] 1.1 在 `core/risk_control.py` 中实现 `update_daily_baseline(state: RiskControlState, current_equity: float) -> None`：  
        - 读取当前 UTC 日期字符串；  
        - 当日期变更时重置 `daily_start_equity` / `daily_start_date` / `daily_loss_pct` / `daily_loss_triggered`；  
        - 当日期未变更时保持字段不变。  
  - [ ] 1.2 在 helper 中添加 INFO 日志用于跨日重置场景（参考 Tech Spec 示例），并在 Dev Notes 中记录最终选定的日志级别策略。  

- [ ] **Task 2 – 将 helper 集成到主循环与状态持久化路径（AC2, AC3）**  
  - [ ] 2.1 在 `_run_iteration()` 或等价入口中，在调用 `check_risk_limits(...)` / 每日亏损检查之前调用 `update_daily_baseline(...)`；  
  - [ ] 2.2 确认 `core/state.save_state()` 在每轮迭代结束时会连同更新后的 `RiskControlState` 一并写入 `portfolio_state.json`；  
  - [ ] 2.3 验证在 `RISK_CONTROL_ENABLED=False` 时的行为（跳过或 no-op）与设计一致，并在 Dev Notes 中说明。  

- [ ] **Task 3 – 单元与集成测试（AC5）**  
  - [ ] 3.1 在 `tests/test_risk_control.py` 或等价文件中新增 `TestUpdateDailyBaseline` 测试类：  
        - 覆盖首次初始化、跨日重置、同日多次调用、边界值（0/None）等场景；  
  - [ ] 3.2 在 `tests/test_risk_control_integration.py` 或等价文件中新增一组集成测试：  
        - 模拟从前一日迭代到次日迭代的状态变化，验证基准重置与持久化行为；  
  - [ ] 3.3 运行 `./scripts/run_tests.sh`，确保所有现有测试（尤其是 Kill-Switch 和信号过滤相关）在加入每日基准逻辑后仍全部通过。

## Dev Notes

### Requirements & Context Summary

- 本 Story 属于 **Epic 7.3: 每日亏损限制功能** 的首个实现 Story，对应 `sprint-status.yaml` 中的 key：`7-3-1-实现每日起始权益记录`。  
- 需求主要来源：  
  - PRD 《风控系统增强 - 产品需求文档》（`docs/prd-risk-control-enhancement.md`）中的每日亏损限制相关功能需求：  
    - **FR12–FR18** 概要描述了每日亏损限制的整体行为，其中本 Story 聚焦于「记录每日起始权益」这一前置能力；  
  - Epic 文档 `docs/epic-risk-control-enhancement.md` 中 **Story 7.3.1: 实现每日起始权益记录** 的详细拆解：  
    - 通过 `RiskControlState.daily_start_equity` / `daily_start_date` 等字段，记录当日基准权益，为 Story 7.3.2/7.3.3/7.3.4 提供输入；  
  - 已完成的 Epic 7.1 故事（尤其是 **Story 7.1.1: 定义 RiskControlState 数据结构**）已经在 `core/risk_control.py` 中引入并测试了 `RiskControlState` 及其序列化/反序列化逻辑。  
- 本 Story 的目标是：在不改变 Kill-Switch 与既有风控语义的前提下，为后续每日亏损限制功能提供**可靠的每日基准记录与持久化机制**。

### Architecture & Implementation Constraints

- **模块边界与职责分配：**  
  - `core/risk_control.py`：负责 `RiskControlState` 结构、每日基准更新 helper（本 Story 主要实现位置）以及后续每日亏损计算逻辑（7.3.2/7.3.3）。  
  - `core/state.py` / `core/persistence.py`：负责从 `portfolio_state.json` 加载与保存 `risk_control` 字段，需确保新增字段的读写保持向后兼容。  
  - `bot.py` / `core/trading_loop.py`：负责在每轮 `_run_iteration()` 开始时调用风控相关 helper（包括 `update_daily_baseline(...)` 与 `check_risk_limits(...)`），不直接操作底层 JSON 文件。  
- **一致性要求：**  
  - 继续复用 Epic 7.1 中建立的模式：单一 `RiskControlState` 来源 + 原子写入持久化 + 容错加载；  
  - 不在 `strategy/`、`llm/`、`display/` 等模块中直接访问或修改每日亏损字段；  
  - 不在本 Story 中引入新的环境变量；每日基准全部从运行期状态和当前权益推导。  
- **禁止事项：**  
  - 禁止在多个模块中维护平行的 `daily_start_equity` / `daily_start_date` 副本，所有读取应来源于 `RiskControlState`；  
  - 禁止在本 Story 中修改 Kill-Switch（Epic 7.2）或 Telegram 命令（Epic 7.4）的语义；  
  - 禁止在本 Story 中实现每日亏损百分比计算或阈值触发逻辑，这些属于 Story 7.3.2 / 7.3.3 / 7.3.4 的范围。

### Project Structure Notes

- 预计主要涉及文件（最终以实际实现为准）：  
  - `core/risk_control.py` —— 新增 `update_daily_baseline(...)` helper，并在 Dev Notes 中记录其使用方式和日志策略；  
  - `core/state.py` / `core/persistence.py` —— 确认 `risk_control.daily_start_equity` / `daily_start_date` / `daily_loss_pct` / `daily_loss_triggered` 的读写在新增逻辑下保持兼容；  
  - `bot.py` / `core/trading_loop.py` —— 在迭代开始阶段调用每日基准更新 helper，并在适当位置传入 `current_equity`；  
  - `tests/test_risk_control.py`、`tests/test_risk_control_integration.py` —— 新增单元与集成测试。  
- 项目整体结构参考：`docs/architecture/06-project-structure-and-mapping.md`，其中 `core/` 层负责状态与风控，`bot.py` 作为主入口协调各模块。

### References

- [Source: docs/epic-risk-control-enhancement.md#Story-7.3.1-实现每日起始权益记录]  
- [Source: docs/prd-risk-control-enhancement.md#每日亏损限制]  
- [Source: docs/sprint-artifacts/7-1-1-定义-riskcontrolstate-数据结构.md]  
- [Source: docs/architecture/index.md]  
- [Source: docs/architecture/06-project-structure-and-mapping.md]  
- [Source: docs/architecture/07-implementation-patterns.md]

## Dev Agent Record

### Context Reference

- `docs/sprint-artifacts/7-3-1-实现每日起始权益记录.context.xml`  
- (相关) `docs/sprint-artifacts/tech-spec-epic-7-1.md`  
- (相关) `docs/sprint-artifacts/epic-7-1-retro-risk-control.md`

### Agent Model Used

- Cascade（Story 草稿由 SM/AI 协同创建，供后续 Dev Story 实施使用）

### Debug Log References

- `core/risk_control.update_daily_baseline` 在跨日重置时输出 INFO 日志：
  - 模板：`"Daily baseline reset: equity=%.2f, date=%s, previous_date=%s, previous_equity=%s"`；
  - 由单元测试 `tests/test_risk_control.py::TestUpdateDailyBaseline.test_initializes_baseline_when_date_is_none` 与 `test_resets_baseline_when_date_changes` 通过 `caplog` 验证；
- 同日多次调用仅在 DEBUG 级别输出 `"Daily baseline unchanged: date=%s, equity=%s"`，避免在 INFO 层刷屏：
  - 由 `tests/test_risk_control.py::TestUpdateDailyBaseline.test_same_day_call_is_idempotent` 覆盖；
- 日志风格（前缀、级别、字段布局）与 Kill-Switch 相关日志保持一致，均使用 UTC 时间并遵循 `docs/architecture/07-implementation-patterns.md` 中约定。

### Completion Notes List

- 已在 `core/risk_control.py` 中实现 `update_daily_baseline(state: RiskControlState, current_equity: float) -> None`，使用 UTC 日期字符串 `YYYY-MM-DD` 作为每日基准键，并在日期变更时原子重置 `daily_start_equity` / `daily_start_date` / `daily_loss_pct` / `daily_loss_triggered`（AC1, AC4）。
- 已在主循环 `bot._run_iteration()` 中，在调用 `check_risk_limits(...)` 之前统一计算 `total_equity = calculate_total_equity()`，当 `RISK_CONTROL_ENABLED=True` 时先调用 `update_daily_baseline(...)`，随后以同一 `total_equity` 调用 `check_risk_limits(...)`；当 `RISK_CONTROL_ENABLED=False` 时跳过 helper 调用，仅执行原有 Kill-Switch 逻辑（满足 AC2 中“跳过或 no-op”之一，并保持 Kill-Switch 语义不变）。
- 通过集成 `core.state.save_state()` 现有持久化路径，将更新后的 `RiskControlState` 序列化到 `portfolio_state.json.risk_control`；新增集成测试验证了同日重启保持原基准、跨日重启后首次迭代按新权益重建基准并正确持久化（AC3）。
- 在 `tests/test_risk_control.py` 中新增 `TestUpdateDailyBaseline` 单元测试类，覆盖首次初始化、跨日重置、同日幂等以及 `daily_start_equity` 为 0/None 的边界场景；在 `tests/test_risk_control_integration.py` 中新增 `DailyBaselineIntegrationTests`，模拟保存/重启/再次保存流程，验证每日基准在同日/跨日情况下的加载与重建语义（AC5）。
- 运行 `./scripts/run_tests.sh` 全量测试（共 515 个用例）全部通过，包含既有 Kill-Switch、信号过滤与 SL/TP 集成测试，表明本 Story 的改动未破坏既有风险控制行为。

### File List

- `core/risk_control.py` —— 新增 `update_daily_baseline(...)` helper 及其 INFO/DEBUG 日志，实现基于 UTC 日期的每日基准更新逻辑，并保持与 Kill-Switch 逻辑解耦。
- `bot.py` —— 在 `_run_iteration()` 中集成每日基准更新：统一计算 `total_equity`，在 `RISK_CONTROL_ENABLED=True` 时调用 `update_daily_baseline(...)`，随后调用 `check_risk_limits(...)`，保持 SL/TP 与后续流程不变。
- `tests/test_risk_control.py` —— 新增 `TestUpdateDailyBaseline` 测试类，覆盖 AC5 中要求的初始化、跨日、同日幂等与 0/None 边界场景，并验证 INFO/DEBUG 日志行为。
- `tests/test_risk_control_integration.py` —— 新增 `DailyBaselineIntegrationTests`，验证 `RiskControlState` 的每日基准在保存/重启后的恢复与跨日重置行为，以及 `portfolio_state.json` 中 `risk_control` 字段的持久化结果。

## Senior Developer Review (AI)

- **Reviewer**: Cascade（Senior Dev 模式）
- **Review Date**: 系统当前日期（UTC）
- **Outcome**: **Approve**（通过，无阻断性问题）

### 1. Acceptance Criteria 覆盖情况

- **AC1 – 每日基准记录逻辑** ✅  
  - 实现：`core/risk_control.py:75-116` 中的 `update_daily_baseline(...)` 使用 `datetime.now(timezone.utc).strftime("%Y-%m-%d")` 计算 `today`，当 `state.daily_start_date != today` 时重置 `daily_start_date`、`daily_start_equity`、`daily_loss_pct`、`daily_loss_triggered`；同日调用保持字段不变，并输出 DEBUG 日志而非 INFO。  
  - 单测：`tests/test_risk_control.py::TestUpdateDailyBaseline` 覆盖初始化、跨日与同日幂等场景，并使用 `caplog` 验证日志内容。

- **AC2 – 与风控检查流程的集成（不改变 Kill-Switch 语义）** ✅  
  - 集成位置：`bot.py:623-656` 中 `_run_iteration()` 在调用 `check_risk_limits(...)` 之前统一计算 `total_equity = calculate_total_equity()`，若 `RISK_CONTROL_ENABLED=True` 则先调用 `update_daily_baseline(_core_state.risk_control_state, current_equity=total_equity)`，随后将同一 `total_equity` 传入 `check_risk_limits(...)`。  
  - 当 `RISK_CONTROL_ENABLED=False` 时，`update_daily_baseline(...)` 不被调用，`check_risk_limits(...)` 仍遵循既有语义直接放行（已有测试覆盖）；Kill-Switch 字段与行为未被修改，相关集成测试（例如 `KillSwitchBlocksEntryIntegrationTests`、执行层 Guard 测试）全部继续通过。

- **AC3 – 持久化与重启语义** ✅  
  - 持久化路径保持不变：`core/state.save_state()` 仍通过 `risk_control_state.to_dict()` 写入 `portfolio_state.json.risk_control`，字段包含 `daily_start_equity` / `daily_start_date` / `daily_loss_pct` / `daily_loss_triggered`。  
  - 集成测试 `tests/test_risk_control_integration.py::DailyBaselineIntegrationTests`：
    - `test_daily_baseline_persists_across_restart_same_day` 验证同日重启时 baseline 不被重置；
    - `test_daily_baseline_resets_on_cross_day_restart` 用前一日 baseline 保存 state，重启后首次调用 `update_daily_baseline(...)` 根据新 `current_equity` 重建 baseline，并再次保存，断言 JSON 中的 `risk_control` 字段已更新为新日期与新基准。
  - 对缺失/损坏 `risk_control` 字段的容错行为由既有集成测试（RiskControlPersistenceIntegrationTests 等）保证；在此基础上，`update_daily_baseline(...)` 能在 `RiskControlState()` 默认状态（日期为 None）下正常建立当日基准。

- **AC4 – 日志与可观测性** ✅  
  - INFO 日志：跨日重置时输出 `"Daily baseline reset: equity=%.2f, date=%s, previous_date=%s, previous_equity=%s"`，包含当前权益、新旧日期及旧基准值，便于审计与排查。  
  - DEBUG 日志：同日重复调用仅输出 `"Daily baseline unchanged: ..."`，避免在 INFO 层产生噪声。  
  - 单测通过 `caplog` 验证 INFO/DEBUG 行为与文案，且日志格式与 Kill-Switch 日志保持一致（模块级 logger + 结构化字段）。

- **AC5 – 单元与集成测试覆盖** ✅  
  - 单测：`tests/test_risk_control.py::TestUpdateDailyBaseline` 覆盖：
    - `daily_start_date is None` 首次初始化；
    - `daily_start_date` 为过去日期的跨日重置；
    - 同日多次调用的幂等性；
    - `daily_start_equity` 为 0 或 None 的边界情况。
  - 集成测试：`tests/test_risk_control_integration.py::DailyBaselineIntegrationTests` 覆盖同日/跨日重启 + 持久化语义。  
  - 全量测试：`./scripts/run_tests.sh` 报告 515 个测试全部通过，包含 Kill-Switch、信号过滤、SL/TP 与风险控制状态持久化相关用例。

### 2. Tasks / Subtasks 一致性

- Story 文档中的 Tasks / Subtasks 仍全部为未勾选状态（`[ ]`），但从实现与测试情况看：
  - Task 1（helper 实现与日志）已在 `core/risk_control.py` 与 `tests/test_risk_control.py` 中完成；
  - Task 2（主循环集成与持久化路径确认）已通过 `_run_iteration()` 集成及既有 `core.state.save_state()` 路径完成；
  - Task 3（单元与集成测试）已通过新增测试类完成。  
- 建议在后续文档维护时由 SM/Dev 手动更新 Tasks 的复选框状态，以保持 Story 文档与代码真实状态一致；当前未出现“标记为完成但实际未实现”的情况。

### 3. 代码质量 / 安全性 / 性能评估

- **可维护性**：
  - 每日基准逻辑集中在 `update_daily_baseline(...)`，主循环仅负责调用与传入 `current_equity`，模块边界清晰；
  - 未在其他模块维护平行的 `daily_start_equity` / `daily_start_date` 副本，符合约束要求。
- **时间与测试可控性**：
  - 当前实现直接使用 `datetime.now(timezone.utc)`，与 AC1 文本保持一致；如未来需要在回测/集成测试中精细控制跨日行为，可考虑在后续 Story 中将该 helper 接入 `core.state.get_current_time()` 抽象（本次不作为阻断项，仅做增强建议）。
- **性能**：
  - `update_daily_baseline(...)` 仅执行 O(1) 内存操作与一次日期格式化调用，相比主循环中网络请求与行情计算开销可以忽略；不会成为性能瓶颈。
- **安全性**：
  - 无外部 I/O 或网络调用；仅操作内存中 `RiskControlState`，不存在额外安全面。

### 4. Action Items（非阻断性建议）

- [Severity: Low][Type: Enhancement] 在后续 Epic/Story 中评估是否将 `update_daily_baseline(...)` 的时间来源从直接调用 `datetime.now(timezone.utc)` 抽象为复用 `core.state.get_current_time()`，以便在回测或复杂测试场景中通过统一的时间提供者控制跨日边界（本 Story 不要求修改，仅建议后续演进时考虑）。
- [Severity: Low][Type: Documentation] 由 SM/Dev 在合适的时机更新本 Story 文档中的 `Tasks / Subtasks` 复选框，以及 `docs/sprint-artifacts/sprint-status.yaml` 中对应条目的状态（例如从 `ready-for-dev` 或 `review` 更新为 `done`），以确保文档与实现状态保持一致。

